/**
 * name: @tresjs/core
 * version: v3.6.0-next.0
 * (c) 2023
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
import { ref as S, computed as k, watchEffect as D, onUnmounted as $, shallowRef as L, watch as re, reactive as pe, readonly as ve, provide as V, inject as de, createRenderer as ge, defineComponent as q, useSlots as ye, getCurrentInstance as J, onMounted as we, openBlock as Ee, createElementBlock as _e, normalizeClass as Ce, normalizeStyle as Me, h as K, Fragment as he } from "vue";
import * as Pe from "three";
import { PerspectiveCamera as G, OrthographicCamera as Ae, Camera as ke, Clock as be, Vector3 as De, Color as F, REVISION as Te, SRGBColorSpace as Le, ACESFilmicToneMapping as xe, PCFSoftShadowMap as Se, WebGLRenderer as I, LoadingManager as Be, TextureLoader as Oe, Vector2 as Re, Raycaster as He, BufferAttribute as Fe, Scene as je } from "three";
import { createEventHook as x, useRafFn as ne, toValue as h, unrefElement as ze, useDevicePixelRatio as $e, usePointer as Ne, useElementBounding as Ie, useWindowSize as Ve, useElementSize as Ge, useFps as We, useMemory as Ue } from "@vueuse/core";
const Ye = ({ sizes: e, scene: a }) => {
  const t = S([]), r = k(
    () => t.value[0]
  ), n = (s, c = !1) => {
    t.value.some(({ uuid: i }) => i === s.uuid) || (c ? l(s) : t.value.push(s));
  }, o = (s) => {
    t.value = t.value.filter(({ uuid: c }) => c !== s.uuid);
  }, l = (s) => {
    const c = s instanceof ke ? s : t.value.find((p) => p.uuid === s);
    if (!c)
      return;
    const i = t.value.filter(({ uuid: p }) => p !== c.uuid);
    t.value = [c, ...i];
  };
  return D(() => {
    e.aspectRatio.value && t.value.forEach((s) => {
      s instanceof G && (s.aspect = e.aspectRatio.value), (s instanceof G || s instanceof Ae) && s.updateProjectionMatrix();
    });
  }), a.userData.tres__registerCamera = n, a.userData.tres__deregisterCamera = o, $(() => {
    t.value = [];
  }), {
    camera: r,
    cameras: t,
    registerCamera: n,
    deregisterCamera: o,
    setCameraActive: l
  };
}, ae = x(), oe = x(), U = x(), T = new be();
let j = 0, z = 0;
const { pause: qe, resume: Je, isActive: Ke } = ne(
  () => {
    ae.trigger({ delta: j, elapsed: z, clock: T }), oe.trigger({ delta: j, elapsed: z, clock: T }), U.trigger({ delta: j, elapsed: z, clock: T });
  },
  { immediate: !1 }
);
U.on(() => {
  j = T.getDelta(), z = T.getElapsedTime();
});
const se = () => ({
  onBeforeLoop: ae.on,
  onLoop: oe.on,
  onAfterLoop: U.on,
  pause: qe,
  resume: Je,
  isActive: Ke
}), Pt = !0, X = "[TresJS ▲ ■ ●] ";
function B() {
  function e(r, n) {
    console.error(`${X} ${r}`, n || "");
  }
  function a(r) {
    console.warn(`${X} ${r}`);
  }
  function t(r, n) {
  }
  return {
    logError: e,
    logWarning: a,
    logMessage: t
  };
}
function At(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof De ? [e.x, e.y, e.z] : e;
}
function Xe(e) {
  return e instanceof F ? e : Array.isArray(e) ? new F(...e) : new F(e);
}
const ie = (e, a) => {
  for (const t of Object.keys(a))
    a[t] instanceof Object && Object.assign(a[t], ie(e[t], a[t]));
  return Object.assign(e || {}, a), e;
}, Qe = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Ze = /* @__PURE__ */ et(Qe);
function Q(e) {
  return e && e.nodeType === 1;
}
function R(e) {
  return e.replace(/-([a-z])/g, (a, t) => t.toUpperCase());
}
function et(e, a) {
  const t = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let n = 0; n < r.length; n++)
    t[r[n]] = !0;
  return a ? (n) => !!t[n.toLowerCase()] : (n) => !!t[n];
}
const tt = (e, a) => {
  const t = /* @__PURE__ */ new Set(), r = [];
  for (const n of e) {
    const o = a(n);
    t.has(o) || (t.add(o), r.push(n));
  }
  return r;
}, Z = (e, a) => {
  if (!a)
    return;
  const t = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((r, n) => r && r[n], e);
}, rt = (e, a, t) => {
  const r = Array.isArray(a) ? a : a.match(/([^[.\]])+/g);
  r && r.reduce((n, o, l) => (n[o] === void 0 && (n[o] = {}), l === r.length - 1 && (n[o] = t), n[o]), e);
};
function ue(e, a) {
  if (Q(e) && Q(a)) {
    const n = e.attributes, o = a.attributes;
    return n.length !== o.length ? !1 : Array.from(n).every(({ name: l, value: s }) => a.getAttribute(l) === s);
  }
  if (e === a)
    return !0;
  if (e === null || typeof e != "object" || a === null || typeof a != "object")
    return !1;
  const t = Object.keys(e), r = Object.keys(a);
  if (t.length !== r.length)
    return !1;
  for (const n of t)
    if (!r.includes(n) || !ue(e[n], a[n]))
      return !1;
  return !0;
}
function nt(e, a) {
  if (!Array.isArray(e) || !Array.isArray(a) || e.length !== a.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (!ue(e[t], a[t]))
      return !1;
  return !0;
}
const at = Array.isArray, ot = Number.parseInt(Te.replace("dev", "")), H = {
  realistic: {
    shadows: !0,
    physicallyCorrectLights: !0,
    outputColorSpace: Le,
    toneMapping: xe,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: Se
    }
  }
};
function st({
  scene: e,
  canvas: a,
  options: t,
  disableRender: r,
  contextParts: { sizes: n, camera: o }
}) {
  const l = k(() => ({
    alpha: h(t.alpha),
    depth: h(t.depth),
    canvas: ze(a),
    context: h(t.context),
    stencil: h(t.stencil),
    antialias: h(t.antialias) === void 0 ? !0 : h(t.antialias),
    precision: h(t.precision),
    powerPreference: h(t.powerPreference),
    premultipliedAlpha: h(t.premultipliedAlpha),
    preserveDrawingBuffer: h(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: h(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: h(t.failIfMajorPerformanceCaveat)
  })), s = L(new I(l.value));
  re(l, () => {
    s.value.dispose(), s.value = new I(l.value);
  }), D(() => {
    s.value.setSize(n.width.value, n.height.value);
  });
  const { pixelRatio: c } = $e();
  D(() => {
    s.value.setPixelRatio(c.value);
  });
  const { logError: i } = B(), f = (() => {
    const d = new I(), C = {
      shadowMap: {
        enabled: d.shadowMap.enabled,
        type: d.shadowMap.type
      },
      toneMapping: d.toneMapping,
      toneMappingExposure: d.toneMappingExposure,
      outputColorSpace: d.outputColorSpace
    };
    return d.dispose(), C;
  })();
  D(() => {
    const d = h(t.preset);
    d && (d in H || i(`Renderer Preset must be one of these: ${Object.keys(H).join(", ")}`), ie(s.value, H[d]));
    const C = (E, _) => {
      const A = h(E), b = () => {
        if (d)
          return Z(H[d], _);
      };
      if (A !== void 0)
        return A;
      const g = b();
      return g !== void 0 ? g : Z(f, _);
    }, w = (E, _) => rt(s.value, _, C(E, _));
    w(t.shadows, "shadowMap.enabled"), w(t.toneMapping, "toneMapping"), w(t.shadowMapType, "shadowMap.type"), ot < 150 && w(!t.useLegacyLights, "physicallyCorrectLights"), w(t.outputColorSpace, "outputColorSpace"), w(t.toneMappingExposure, "toneMappingExposure");
    const P = C(t.clearColor, "clearColor");
    P && s.value.setClearColor(
      P ? Xe(P) : new F(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: u, resume: m, onLoop: v } = se();
  return v(() => {
    o.value && !h(r) && s.value.render(e, o.value);
  }), m(), $(() => {
    u(), s.value.dispose(), s.value.forceContextLoss();
  }), {
    renderer: s
  };
}
const ee = (e) => typeof e == "function", it = (e) => !!e && e.constructor === Array;
function ut(e) {
  const a = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (a.nodes[t.name] = t), t.material && !a.materials[t.material.name] && (a.materials[t.material.name] = t.material);
  }), a;
}
async function kt(e, a, t, r, n) {
  const { logError: o } = B(), l = new e();
  n && n(l), t && t(l);
  const c = (Array.isArray(a) ? a : [a]).map(
    (i) => new Promise((p, f) => {
      l.load(
        i,
        (u) => {
          u.scene && Object.assign(u, ut(u.scene)), p(u);
        },
        r,
        (u) => f(o("[useLoader] - Failed to load resource", u))
      );
    })
  );
  return it(a) ? await Promise.all(c) : await c[0];
}
async function bt(e) {
  const a = new Be(), t = new Oe(a), r = (n) => new Promise((o, l) => {
    t.load(
      n,
      (s) => o(s),
      () => null,
      () => {
        l(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (at(e)) {
    const n = await Promise.all(e.map((o) => r(o)));
    return e.length > 1 ? n : n[0];
  } else {
    const {
      map: n,
      displacementMap: o,
      normalMap: l,
      roughnessMap: s,
      metalnessMap: c,
      aoMap: i,
      alphaMap: p,
      matcap: f
    } = e;
    return {
      map: n ? await r(n) : null,
      displacementMap: o ? await r(o) : null,
      normalMap: l ? await r(l) : null,
      roughnessMap: s ? await r(s) : null,
      metalnessMap: c ? await r(c) : null,
      aoMap: i ? await r(i) : null,
      alphaMap: p ? await r(p) : null,
      matcap: f ? await r(f) : null
    };
  }
}
const lt = (e, { renderer: a, camera: t, raycaster: r }) => {
  const n = k(() => a.value.domElement), { x: o, y: l } = Ne({ target: n }), { width: s, height: c, top: i, left: p } = Ie(n), f = ({ x: g, y: M }) => {
    if (n.value)
      return {
        x: (g - p.value) / s.value * 2 - 1,
        y: -((M - i.value) / c.value) * 2 + 1
      };
  }, u = ({ x: g, y: M }) => {
    if (t.value)
      return r.value.setFromCamera(new Re(g, M), t.value), r.value.intersectObjects(e.value, !1);
  }, m = (g) => {
    const M = f({
      x: (g == null ? void 0 : g.clientX) ?? o.value,
      y: (g == null ? void 0 : g.clientY) ?? l.value
    });
    return M ? u(M) || [] : [];
  }, v = k(() => m()), d = x(), C = x(), w = (g, M) => {
    g.trigger({ event: M, intersects: m(M) });
  }, P = (g) => {
    w(C, g);
  };
  let E;
  const _ = (g) => {
    var M;
    E = (M = m(g)[0]) == null ? void 0 : M.object;
  }, A = (g) => {
    var M;
    g instanceof PointerEvent && E === ((M = m(g)[0]) == null ? void 0 : M.object) && w(d, g);
  }, b = (g) => C.trigger({ event: g, intersects: [] });
  return n.value.addEventListener("pointerup", A), n.value.addEventListener("pointerdown", _), n.value.addEventListener("pointermove", P), n.value.addEventListener("pointerleave", b), $(() => {
    n != null && n.value && (n.value.removeEventListener("pointerup", A), n.value.removeEventListener("pointerdown", _), n.value.removeEventListener("pointermove", P), n.value.removeEventListener("pointerleave", b));
  }), {
    intersects: v,
    onClick: (g) => d.on(g).off,
    onPointerMove: (g) => C.on(g).off
  };
};
function Dt() {
  const { logWarning: e } = B();
  function a(o, l, s) {
    let c = null;
    return o.traverse((i) => {
      i[l] === s && (c = i);
    }), c || e(`Child with ${l} '${s}' not found.`), c;
  }
  function t(o, l, s) {
    const c = [];
    return o.traverse((i) => {
      i[l].includes(s) && c.push(i);
    }), c.length || e(`Children with ${l} '${s}' not found.`), c;
  }
  function r(o, l) {
    return a(o, "name", l);
  }
  function n(o, l) {
    return t(o, "name", l);
  }
  return {
    seek: a,
    seekByName: r,
    seekAll: t,
    seekAllByName: n
  };
}
const ct = ({ scene: e, contextParts: a }) => {
  const t = pe({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), r = S(/* @__PURE__ */ new Set()), n = (u) => {
    r.value.add(u);
  }, o = (u) => {
    r.value.delete(u);
  }, l = (u) => {
    Object.values(t).forEach((m) => m.delete(u)), o(u);
  }, s = (u) => {
    const { onClick: m, onPointerMove: v, onPointerEnter: d, onPointerLeave: C } = u;
    m && t.click.set(u, m), v && t.pointerMove.set(u, v), d && t.pointerEnter.set(u, d), C && t.pointerLeave.set(u, C);
  };
  e.userData.tres__registerAtPointerEventHandler = s, e.userData.tres__deregisterAtPointerEventHandler = l, e.userData.tres__registerBlockingObjectAtPointerEventHandler = n, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = o;
  const c = k(
    () => tt(
      [
        ...Array.from(r.value),
        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
      ],
      ({ uuid: u }) => u
    )
  ), { onClick: i, onPointerMove: p } = lt(c, a);
  i(({ intersects: u, event: m }) => {
    var v;
    u.length && ((v = t.click.get(u[0].object)) == null || v(u[0], m));
  });
  let f;
  return p(({ intersects: u, event: m }) => {
    var P, E, _, A;
    const v = (P = u == null ? void 0 : u[0]) == null ? void 0 : P.object, { pointerLeave: d, pointerEnter: C, pointerMove: w } = t;
    f && f !== v && ((E = d.get(f)) == null || E(f, m)), v && (f !== v && ((_ = C.get(v)) == null || _(u[0], m)), (A = w.get(v)) == null || A(u[0], m)), f = v || null;
  }), {
    registerObject: s,
    deregisterObject: l
  };
};
function ft(e) {
  let a = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const r = t.geometry, n = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, o = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, l = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, s = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, c = n + o + l + s;
      a += c;
    }
  }), a;
}
const W = S({}), Y = (e) => Object.assign(W.value, e);
function mt({
  scene: e,
  canvas: a,
  windowSize: t,
  disableRender: r,
  rendererOptions: n
}) {
  const o = k(
    () => h(t) ? Ve() : Ge(h(a).parentElement)
  ), l = k(() => o.value.width.value), s = k(() => o.value.height.value), c = k(() => l.value / s.value), i = {
    height: s,
    width: l,
    aspectRatio: c
  }, p = L(e), {
    camera: f,
    cameras: u,
    registerCamera: m,
    deregisterCamera: v,
    setCameraActive: d
  } = Ye({ sizes: i, scene: e }), { renderer: C } = st(
    {
      scene: e,
      canvas: a,
      options: n,
      contextParts: { sizes: i, camera: f },
      disableRender: r
    }
  ), w = {
    sizes: i,
    scene: p,
    camera: f,
    cameras: ve(u),
    renderer: C,
    raycaster: L(new He()),
    controls: S(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: Y,
    registerCamera: m,
    setCameraActive: d,
    deregisterCamera: v
  };
  V("useTres", w);
  const P = 100, E = We({ every: P }), { isSupported: _, memory: A } = Ue({ interval: P }), b = 160;
  let g = performance.now();
  const M = ({ timestamp: O }) => {
    w.scene.value && (w.perf.memory.allocatedMem = ft(w.scene.value)), O - g >= P && (g = O, w.perf.fps.accumulator.push(E.value), w.perf.fps.accumulator.length > b && w.perf.fps.accumulator.shift(), w.perf.fps.value = E.value, _.value && A.value && (w.perf.memory.accumulator.push(A.value.usedJSHeapSize / 1024 / 1024), w.perf.memory.accumulator.length > b && w.perf.memory.accumulator.shift(), w.perf.memory.currentMem = w.perf.memory.accumulator.reduce((fe, me) => fe + me, 0) / w.perf.memory.accumulator.length));
  };
  let N = 0;
  const le = 1, { pause: ce, resume: _t } = ne(({ delta: O }) => {
    window.__TRES__DEVTOOLS__ && (M({ timestamp: performance.now() }), N += O, N >= le && (window.__TRES__DEVTOOLS__.cb(w), N = 0));
  }, { immediate: !0 });
  return $(() => {
    ce();
  }), w;
}
function pt() {
  const e = de("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const Tt = pt;
let y = null;
const { logError: te } = B(), vt = {
  createElement(e, a, t, r) {
    var l, s;
    if (r || (r = {}), r.args || (r.args = []), e === "template" || Ze(e))
      return null;
    let n = e.replace("Tres", ""), o;
    if (e === "primitive") {
      (r == null ? void 0 : r.object) === void 0 && te("Tres primitives need a prop 'object'");
      const c = r.object;
      n = c.type, o = Object.assign(c, { type: n, attach: r.attach, primitive: !0 });
    } else {
      const c = W.value[n];
      c || te(`${n} is not defined on the THREE namespace. Use extend to add it to the catalog.`), o = new c(...r.args);
    }
    return o.isCamera && (r != null && r.position || o.position.set(3, 3, 3), r != null && r.lookAt || o.lookAt(0, 0, 0)), (r == null ? void 0 : r.attach) === void 0 && (o.isMaterial ? o.attach = "material" : o.isBufferGeometry && (o.attach = "geometry")), o.isObject3D && ((l = r == null ? void 0 : r.material) != null && l.isMaterial && (o.userData.tres__materialViaProp = !0), (s = r == null ? void 0 : r.geometry) != null && s.isBufferGeometry && (o.userData.tres__geometryViaProp = !0)), o.userData = {
      ...o.userData,
      tres__name: n
    }, o;
  },
  insert(e, a) {
    var r, n, o, l;
    a && a.isScene && (y = a);
    const t = a || y;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(y != null && y.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (n = y == null ? void 0 : (r = y.userData).tres__registerCamera) == null || n.call(r, e);
      }
      if (e != null && e.onClick || e != null && e.onPointerMove || e != null && e.onPointerEnter || e != null && e.onPointerLeave) {
        if (!(y != null && y.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (l = y == null ? void 0 : (o = y.userData).tres__registerAtPointerEventHandler) == null || l.call(o, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var a, t;
    if (e) {
      if (e.isObject3D) {
        const r = e, n = (i) => {
          var f, u;
          const p = i;
          i.userData.tres__materialViaProp || (f = p.material) == null || f.dispose(), i.userData.tres__geometryViaProp || (u = p.geometry) == null || u.dispose();
        }, o = y == null ? void 0 : y.userData.tres__deregisterAtPointerEventHandler, l = y == null ? void 0 : y.userData.tres__deregisterBlockingObjectAtPointerEventHandler, s = (i) => {
          var p, f;
          if (!l)
            throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
          if ((f = y == null ? void 0 : (p = y.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || f.call(p, i), !o)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          (i != null && i.onClick || i != null && i.onPointerMove || i != null && i.onPointerEnter || i != null && i.onPointerLeave) && (o == null || o(i));
        }, c = (i) => {
          const p = y == null ? void 0 : y.userData.tres__deregisterCamera;
          if (!p)
            throw "could not find tres__deregisterCamera on scene's userData";
          i.isCamera && (p == null || p(i));
        };
        r.traverse((i) => {
          n(i), c(i), s == null || s(i);
        }), n(r), c(r), s == null || s(r);
      }
      (a = e.removeFromParent) == null || a.call(e), (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, a, t, r) {
    var n, o, l, s;
    if (e) {
      let c = e, i = a;
      if (e.isObject3D && i === "blocks-pointer-events") {
        r || r === "" ? (o = y == null ? void 0 : (n = y.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || o.call(n, e) : (s = y == null ? void 0 : (l = y.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || s.call(l, e);
        return;
      }
      let p = R(i), f = c == null ? void 0 : c[p];
      if (i === "args") {
        const m = e, v = t ?? [], d = r ?? [], C = e.userData.tres__name || e.type;
        C && v.length && !nt(v, d) && (c = Object.assign(m, new W.value[C](...r)));
        return;
      }
      if (c.type === "BufferGeometry") {
        if (i === "args")
          return;
        c.setAttribute(
          R(i),
          new Fe(...r)
        );
        return;
      }
      if (i.includes("-") && f === void 0) {
        const m = i.split("-");
        f = m.reduce((v, d) => v[R(d)], c), i = m.pop(), p = i.toLowerCase(), f != null && f.set || (c = m.reduce((v, d) => v[R(d)], c));
      }
      let u = r;
      if (u === "" && (u = !0), ee(f)) {
        Array.isArray(u) ? e[p](...u) : e[p](u);
        return;
      }
      !(f != null && f.set) && !ee(f) ? c[p] = u : f.constructor === u.constructor && (f != null && f.copy) ? f == null || f.copy(u) : Array.isArray(u) ? f.set(...u) : !f.isColor && f.setScalar ? f.setScalar(u) : f.set(u);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
}, { render: dt } = ge(vt);
Y(Pe);
const gt = ["data-scene"], yt = /* @__PURE__ */ q({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: a }) {
    var u;
    const t = e, { logWarning: r } = B(), n = S(), o = L(new je());
    se();
    const l = ye(), s = (u = J()) == null ? void 0 : u.appContext.app, c = (m) => q({
      setup() {
        var d;
        const v = (d = J()) == null ? void 0 : d.appContext;
        return v && (v.app = s), V("useTres", m), V("extend", Y), () => K(he, null, l != null && l.default ? l.default() : []);
      }
    }), i = (m) => {
      const v = c(m);
      dt(K(v), o.value);
    }, p = k(() => t.disableRender), f = L(null);
    return a({ context: f }), we(() => {
      const m = n;
      f.value = mt({
        scene: o.value,
        canvas: m,
        windowSize: t.windowSize,
        disableRender: p,
        rendererOptions: t
      }), ct({ scene: o.value, contextParts: f.value });
      const { registerCamera: v, camera: d, cameras: C, deregisterCamera: w } = f.value;
      i(f.value);
      const P = () => {
        const E = new G(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        E.position.set(3, 3, 3), E.lookAt(0, 0, 0), v(E);
        const _ = D(() => {
          C.value.length >= 2 && (E.removeFromParent(), w(E), _ == null || _());
        });
      };
      re(
        () => t.camera,
        (E, _) => {
          E && v(E), _ && (_.removeFromParent(), w(_));
        },
        {
          immediate: !0
        }
      ), d.value || (r(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), P());
    }), (m, v) => (Ee(), _e("canvas", {
      ref_key: "canvas",
      ref: n,
      "data-scene": o.value.uuid,
      class: Ce(m.$attrs.class),
      style: Me({
        display: "block",
        width: "100%",
        height: "100%",
        position: m.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...m.$attrs.style
      })
    }, null, 14, gt));
  }
}), wt = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], Et = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !wt.includes(e) || e === "primitive"
    }
  }
}, Lt = Et, xt = {
  install(e) {
    e.component("TresCanvas", yt);
  }
};
export {
  yt as TresCanvas,
  W as catalogue,
  xt as default,
  Y as extend,
  Pt as isProd,
  Xe as normalizeColor,
  At as normalizeVectorFlexibleParam,
  Lt as templateCompilerOptions,
  ut as trasverseObjects,
  Ye as useCamera,
  kt as useLoader,
  B as useLogger,
  ct as usePointerEventHandler,
  lt as useRaycaster,
  se as useRenderLoop,
  st as useRenderer,
  Dt as useSeek,
  bt as useTexture,
  Tt as useTres,
  pt as useTresContext,
  mt as useTresContextProvider
};
