/**
 * name: @tresjs/core
 * version: v3.6.1
 * (c) 2024
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
import { ref as L, computed as k, watchEffect as D, onUnmounted as $, shallowRef as x, watch as ne, reactive as ve, readonly as ge, provide as W, inject as ye, createRenderer as he, defineComponent as J, useSlots as we, getCurrentInstance as K, onMounted as Ee, openBlock as be, createElementBlock as Ce, normalizeClass as _e, unref as Me, normalizeStyle as Pe, h as X, Fragment as Ae } from "vue";
import * as ke from "three";
import { PerspectiveCamera as G, OrthographicCamera as De, Camera as xe, Clock as Te, Vector3 as Se, Color as H, REVISION as Le, SRGBColorSpace as je, ACESFilmicToneMapping as Be, PCFSoftShadowMap as Oe, WebGLRenderer as I, LoadingManager as Re, TextureLoader as He, Vector2 as ze, Raycaster as Fe, BufferAttribute as $e, Scene as Ne } from "three";
import { createEventHook as S, useRafFn as se, toValue as _, unrefElement as Ie, useDevicePixelRatio as Ve, usePointer as We, useElementBounding as Ge, useWindowSize as qe, useElementSize as Ue, refDebounced as Ye, useFps as Je, useMemory as Ke } from "@vueuse/core";
const Xe = "@tresjs/core", Qe = "module", Ze = "3.6.1", et = "pnpm@8.10.2", tt = "Declarative ThreeJS using Vue Components", rt = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", nt = "MIT", st = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
], ot = !1, at = {
  ".": {
    types: "./dist/index.d.ts",
    require: "./dist/tres.umd.cjs",
    import: "./dist/tres.js"
  },
  "./components": {
    types: "./dist/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/utils/index.d.ts"
  },
  "./*": "./*"
}, it = "./dist/tres.js", lt = "./dist/tres.js", ut = "./dist/index.d.ts", ct = [
  "dist",
  "*.d.ts"
], ft = {
  access: "public"
}, pt = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint . --ext .js,.jsx,.ts,.tsx,.vue",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts"
}, dt = {
  three: ">=0.133",
  vue: ">=3.3"
}, mt = {
  "@alvarosabu/utils": "^3.1.1",
  "@vueuse/core": "^10.7.0"
}, vt = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.9.0",
  "@tresjs/cientos": "3.6.0",
  "@tresjs/eslint-config-vue": "^0.2.1",
  "@types/three": "^0.159.0",
  "@typescript-eslint/eslint-plugin": "^6.14.0",
  "@typescript-eslint/parser": "^6.14.0",
  "@vitejs/plugin-vue": "^4.5.2",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^1.0.4",
  "@vue/test-utils": "^2.4.3",
  eslint: "^8.55.0",
  "eslint-plugin-vue": "^9.19.2",
  esno: "^4.0.0",
  gsap: "^3.12.3",
  jsdom: "^23.0.1",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.1",
  "release-it": "^17.0.1",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.11.0",
  three: "^0.159.0",
  unocss: "^0.58.0",
  unplugin: "^1.5.1",
  "unplugin-vue-components": "^0.26.0",
  vite: "^5.0.8",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.6.4",
  "vite-plugin-inspect": "^0.8.1",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.0.0-rc.31",
  vitest: "^1.0.4",
  vue: "^3.3.11",
  "vue-demi": "^0.14.6"
}, gt = {
  name: Xe,
  type: Qe,
  version: Ze,
  packageManager: et,
  description: tt,
  author: rt,
  license: nt,
  keywords: st,
  sideEffects: ot,
  exports: at,
  main: it,
  module: lt,
  types: ut,
  files: ct,
  publishConfig: ft,
  scripts: pt,
  peerDependencies: dt,
  dependencies: mt,
  devDependencies: vt
}, yt = ({ sizes: e, scene: s }) => {
  const t = L([]), r = k(
    () => t.value[0]
  ), n = (a, l = !1) => {
    t.value.some(({ uuid: c }) => c === a.uuid) || (l ? u(a) : t.value.push(a));
  }, o = (a) => {
    t.value = t.value.filter(({ uuid: l }) => l !== a.uuid);
  }, u = (a) => {
    const l = a instanceof xe ? a : t.value.find((d) => d.uuid === a);
    if (!l)
      return;
    const c = t.value.filter(({ uuid: d }) => d !== l.uuid);
    t.value = [l, ...c];
  };
  return D(() => {
    e.aspectRatio.value && t.value.forEach((a) => {
      a instanceof G && (a.aspect = e.aspectRatio.value), (a instanceof G || a instanceof De) && a.updateProjectionMatrix();
    });
  }), s.userData.tres__registerCamera = n, s.userData.tres__deregisterCamera = o, $(() => {
    t.value = [];
  }), {
    camera: r,
    cameras: t,
    registerCamera: n,
    deregisterCamera: o,
    setCameraActive: u
  };
}, oe = S(), ae = S(), U = S(), T = new Te();
let z = 0, F = 0;
const { pause: ht, resume: wt, isActive: Et } = se(
  () => {
    oe.trigger({ delta: z, elapsed: F, clock: T }), ae.trigger({ delta: z, elapsed: F, clock: T }), U.trigger({ delta: z, elapsed: F, clock: T });
  },
  { immediate: !1 }
);
U.on(() => {
  z = T.getDelta(), F = T.getElapsedTime();
});
const ie = () => ({
  onBeforeLoop: oe.on,
  onLoop: ae.on,
  onAfterLoop: U.on,
  pause: ht,
  resume: wt,
  isActive: Et
}), Yt = !0, Q = "[TresJS ▲ ■ ●] ";
function j() {
  function e(r, n) {
    console.error(`${Q} ${r}`, n || "");
  }
  function s(r) {
    console.warn(`${Q} ${r}`);
  }
  function t(r, n) {
  }
  return {
    logError: e,
    logWarning: s,
    logMessage: t
  };
}
function Jt(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Se ? [e.x, e.y, e.z] : e;
}
function bt(e) {
  return e instanceof H ? e : Array.isArray(e) ? new H(...e) : new H(e);
}
const le = (e, s) => {
  for (const t of Object.keys(s))
    s[t] instanceof Object && Object.assign(s[t], le(e[t], s[t]));
  return Object.assign(e || {}, s), e;
}, Ct = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", _t = /* @__PURE__ */ Mt(Ct);
function Z(e) {
  return e && e.nodeType === 1;
}
function O(e) {
  return e.replace(/-([a-z])/g, (s, t) => t.toUpperCase());
}
function Mt(e, s) {
  const t = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let n = 0; n < r.length; n++)
    t[r[n]] = !0;
  return s ? (n) => !!t[n.toLowerCase()] : (n) => !!t[n];
}
const Pt = (e, s) => {
  const t = /* @__PURE__ */ new Set(), r = [];
  for (const n of e) {
    const o = s(n);
    t.has(o) || (t.add(o), r.push(n));
  }
  return r;
}, ee = (e, s) => {
  if (!s)
    return;
  const t = Array.isArray(s) ? s : s.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((r, n) => r && r[n], e);
}, At = (e, s, t) => {
  const r = Array.isArray(s) ? s : s.match(/([^[.\]])+/g);
  r && r.reduce((n, o, u) => (n[o] === void 0 && (n[o] = {}), u === r.length - 1 && (n[o] = t), n[o]), e);
};
function ue(e, s) {
  if (Z(e) && Z(s)) {
    const n = e.attributes, o = s.attributes;
    return n.length !== o.length ? !1 : Array.from(n).every(({ name: u, value: a }) => s.getAttribute(u) === a);
  }
  if (e === s)
    return !0;
  if (e === null || typeof e != "object" || s === null || typeof s != "object")
    return !1;
  const t = Object.keys(e), r = Object.keys(s);
  if (t.length !== r.length)
    return !1;
  for (const n of t)
    if (!r.includes(n) || !ue(e[n], s[n]))
      return !1;
  return !0;
}
function kt(e, s) {
  if (!Array.isArray(e) || !Array.isArray(s) || e.length !== s.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (!ue(e[t], s[t]))
      return !1;
  return !0;
}
const Dt = Array.isArray, xt = Number.parseInt(Le.replace("dev", "")), R = {
  realistic: {
    shadows: !0,
    physicallyCorrectLights: !0,
    outputColorSpace: je,
    toneMapping: Be,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: !0,
      type: Oe
    }
  }
};
function Tt({
  scene: e,
  canvas: s,
  options: t,
  disableRender: r,
  contextParts: { sizes: n, camera: o }
}) {
  const u = k(() => ({
    alpha: _(t.alpha),
    depth: _(t.depth),
    canvas: Ie(s),
    context: _(t.context),
    stencil: _(t.stencil),
    antialias: _(t.antialias) === void 0 ? !0 : _(t.antialias),
    precision: _(t.precision),
    powerPreference: _(t.powerPreference),
    premultipliedAlpha: _(t.premultipliedAlpha),
    preserveDrawingBuffer: _(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: _(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: _(t.failIfMajorPerformanceCaveat)
  })), a = x(new I(u.value));
  ne(u, () => {
    a.value.dispose(), a.value = new I(u.value);
  }), D(() => {
    a.value.setSize(n.width.value, n.height.value);
  });
  const { pixelRatio: l } = Ve();
  D(() => {
    a.value.setPixelRatio(l.value);
  });
  const { logError: c } = j(), f = (() => {
    const p = new I(), y = {
      shadowMap: {
        enabled: p.shadowMap.enabled,
        type: p.shadowMap.type
      },
      toneMapping: p.toneMapping,
      toneMappingExposure: p.toneMappingExposure,
      outputColorSpace: p.outputColorSpace
    };
    return p.dispose(), y;
  })();
  D(() => {
    const p = _(t.preset);
    p && (p in R || c(`Renderer Preset must be one of these: ${Object.keys(R).join(", ")}`), le(a.value, R[p]));
    const y = (M, P) => {
      const E = _(M), A = () => {
        if (p)
          return ee(R[p], P);
      };
      if (E !== void 0)
        return E;
      const v = A();
      return v !== void 0 ? v : ee(f, P);
    }, b = (M, P) => At(a.value, P, y(M, P));
    b(t.shadows, "shadowMap.enabled"), b(t.toneMapping, "toneMapping"), b(t.shadowMapType, "shadowMap.type"), xt < 150 && b(!t.useLegacyLights, "physicallyCorrectLights"), b(t.outputColorSpace, "outputColorSpace"), b(t.toneMappingExposure, "toneMappingExposure");
    const w = y(t.clearColor, "clearColor");
    w && a.value.setClearColor(
      w ? bt(w) : new H(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: i, resume: m, onLoop: h } = ie();
  return h(() => {
    o.value && !_(r) && a.value.render(e, o.value);
  }), m(), $(() => {
    i(), a.value.dispose(), a.value.forceContextLoss();
  }), {
    renderer: a
  };
}
const te = (e) => typeof e == "function", St = (e) => !!e && e.constructor === Array;
function Lt(e) {
  const s = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (s.nodes[t.name] = t), t.material && !s.materials[t.material.name] && (s.materials[t.material.name] = t.material);
  }), s;
}
async function Kt(e, s, t, r, n) {
  const { logError: o } = j(), u = new e();
  n && n(u), t && t(u);
  const l = (Array.isArray(s) ? s : [s]).map(
    (c) => new Promise((d, f) => {
      u.load(
        c,
        (i) => {
          i.scene && Object.assign(i, Lt(i.scene)), d(i);
        },
        r,
        (i) => f(o("[useLoader] - Failed to load resource", i))
      );
    })
  );
  return St(s) ? await Promise.all(l) : await l[0];
}
async function Xt(e) {
  const s = new Re(), t = new He(s), r = (n) => new Promise((o, u) => {
    t.load(
      n,
      (a) => o(a),
      () => null,
      () => {
        u(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Dt(e)) {
    const n = await Promise.all(e.map((o) => r(o)));
    return e.length > 1 ? n : n[0];
  } else {
    const {
      map: n,
      displacementMap: o,
      normalMap: u,
      roughnessMap: a,
      metalnessMap: l,
      aoMap: c,
      alphaMap: d,
      matcap: f
    } = e;
    return {
      map: n ? await r(n) : null,
      displacementMap: o ? await r(o) : null,
      normalMap: u ? await r(u) : null,
      roughnessMap: a ? await r(a) : null,
      metalnessMap: l ? await r(l) : null,
      aoMap: c ? await r(c) : null,
      alphaMap: d ? await r(d) : null,
      matcap: f ? await r(f) : null
    };
  }
}
const jt = (e, { renderer: s, camera: t, raycaster: r }) => {
  const n = k(() => s.value.domElement), { x: o, y: u } = We({ target: n }), { width: a, height: l, top: c, left: d } = Ge(n), f = ({ x: v, y: C }) => {
    if (n.value)
      return {
        x: (v - d.value) / a.value * 2 - 1,
        y: -((C - c.value) / l.value) * 2 + 1
      };
  }, i = ({ x: v, y: C }) => {
    if (t.value)
      return r.value.setFromCamera(new ze(v, C), t.value), r.value.intersectObjects(e.value, !1);
  }, m = (v) => {
    const C = f({
      x: (v == null ? void 0 : v.clientX) ?? o.value,
      y: (v == null ? void 0 : v.clientY) ?? u.value
    });
    return C ? i(C) || [] : [];
  }, h = k(() => m()), p = S(), y = S(), b = (v, C) => {
    v.trigger({ event: C, intersects: m(C) });
  }, w = (v) => {
    b(y, v);
  };
  let M;
  const P = (v) => {
    var C;
    M = (C = m(v)[0]) == null ? void 0 : C.object;
  }, E = (v) => {
    var C;
    v instanceof PointerEvent && M === ((C = m(v)[0]) == null ? void 0 : C.object) && b(p, v);
  }, A = (v) => y.trigger({ event: v, intersects: [] });
  return n.value.addEventListener("pointerup", E), n.value.addEventListener("pointerdown", P), n.value.addEventListener("pointermove", w), n.value.addEventListener("pointerleave", A), $(() => {
    n != null && n.value && (n.value.removeEventListener("pointerup", E), n.value.removeEventListener("pointerdown", P), n.value.removeEventListener("pointermove", w), n.value.removeEventListener("pointerleave", A));
  }), {
    intersects: h,
    onClick: (v) => p.on(v).off,
    onPointerMove: (v) => y.on(v).off
  };
};
function Qt() {
  const { logWarning: e } = j();
  function s(o, u, a) {
    let l = null;
    return o.traverse((c) => {
      c[u] === a && (l = c);
    }), l || e(`Child with ${u} '${a}' not found.`), l;
  }
  function t(o, u, a) {
    const l = [];
    return o.traverse((c) => {
      c[u].includes(a) && l.push(c);
    }), l.length || e(`Children with ${u} '${a}' not found.`), l;
  }
  function r(o, u) {
    return s(o, "name", u);
  }
  function n(o, u) {
    return t(o, "name", u);
  }
  return {
    seek: s,
    seekByName: r,
    seekAll: t,
    seekAllByName: n
  };
}
const Bt = ({ scene: e, contextParts: s }) => {
  const t = ve({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), r = L(/* @__PURE__ */ new Set()), n = (i) => {
    r.value.add(i);
  }, o = (i) => {
    r.value.delete(i);
  }, u = (i) => {
    Object.values(t).forEach((m) => m.delete(i)), o(i);
  }, a = (i) => {
    const { onClick: m, onPointerMove: h, onPointerEnter: p, onPointerLeave: y } = i;
    m && t.click.set(i, m), h && t.pointerMove.set(i, h), p && t.pointerEnter.set(i, p), y && t.pointerLeave.set(i, y);
  };
  e.userData.tres__registerAtPointerEventHandler = a, e.userData.tres__deregisterAtPointerEventHandler = u, e.userData.tres__registerBlockingObjectAtPointerEventHandler = n, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = o;
  const l = k(
    () => Pt(
      [
        ...Array.from(r.value),
        ...Object.values(t).map((i) => Array.from(i.keys())).flat()
      ],
      ({ uuid: i }) => i
    )
  ), { onClick: c, onPointerMove: d } = jt(l, s);
  c(({ intersects: i, event: m }) => {
    var h;
    i.length && ((h = t.click.get(i[0].object)) == null || h(i[0], m));
  });
  let f;
  return d(({ intersects: i, event: m }) => {
    var w, M, P, E;
    const h = (w = i == null ? void 0 : i[0]) == null ? void 0 : w.object, { pointerLeave: p, pointerEnter: y, pointerMove: b } = t;
    f && f !== h && ((M = p.get(f)) == null || M(f, m)), h && (f !== h && ((P = y.get(h)) == null || P(i[0], m)), (E = b.get(h)) == null || E(i[0], m)), f = h || null;
  }), {
    registerObject: a,
    deregisterObject: u
  };
};
function Ot(e) {
  let s = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const r = t.geometry, n = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, o = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, u = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = n + o + u + a;
      s += l;
    }
  }), s;
}
const q = L({}), Y = (e) => Object.assign(q.value, e);
function Rt({
  scene: e,
  canvas: s,
  windowSize: t,
  disableRender: r,
  rendererOptions: n
}) {
  const o = k(
    () => _(t) ? qe() : Ue(_(s).parentElement)
  ), u = x({
    width: 0,
    height: 0
  }), a = Ye(u, 10), l = D(() => {
    u.value = {
      width: o.value.width.value,
      height: o.value.height.value
    };
  }), c = k(() => a.value.width / a.value.height), d = {
    height: k(() => a.value.height),
    width: k(() => a.value.width),
    aspectRatio: c
  }, f = x(e), {
    camera: i,
    cameras: m,
    registerCamera: h,
    deregisterCamera: p,
    setCameraActive: y
  } = yt({ sizes: d, scene: e }), { renderer: b } = Tt(
    {
      scene: e,
      canvas: s,
      options: n,
      contextParts: { sizes: d, camera: i },
      disableRender: r
    }
  ), w = {
    sizes: d,
    scene: f,
    camera: i,
    cameras: ge(m),
    renderer: b,
    raycaster: x(new Fe()),
    controls: L(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: Y,
    registerCamera: h,
    setCameraActive: y,
    deregisterCamera: p
  };
  W("useTres", w);
  const M = 100, P = Je({ every: M }), { isSupported: E, memory: A } = Ke({ interval: M }), v = 160;
  let C = performance.now();
  const ce = ({ timestamp: B }) => {
    w.scene.value && (w.perf.memory.allocatedMem = Ot(w.scene.value)), B - C >= M && (C = B, w.perf.fps.accumulator.push(P.value), w.perf.fps.accumulator.length > v && w.perf.fps.accumulator.shift(), w.perf.fps.value = P.value, E.value && A.value && (w.perf.memory.accumulator.push(A.value.usedJSHeapSize / 1024 / 1024), w.perf.memory.accumulator.length > v && w.perf.memory.accumulator.shift(), w.perf.memory.currentMem = w.perf.memory.accumulator.reduce((de, me) => de + me, 0) / w.perf.memory.accumulator.length));
  };
  let N = 0;
  const fe = 1, { pause: pe, resume: Wt } = se(({ delta: B }) => {
    window.__TRES__DEVTOOLS__ && (ce({ timestamp: performance.now() }), N += B, N >= fe && (window.__TRES__DEVTOOLS__.cb(w), N = 0));
  }, { immediate: !0 });
  return $(() => {
    l(), pe();
  }), w;
}
function Ht() {
  const e = ye("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
const Zt = Ht;
let g = null;
const { logError: re } = j(), V = [
  "onClick",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave"
], zt = {
  createElement(e, s, t, r) {
    var u, a;
    if (r || (r = {}), r.args || (r.args = []), e === "template" || _t(e))
      return null;
    let n = e.replace("Tres", ""), o;
    if (e === "primitive") {
      (r == null ? void 0 : r.object) === void 0 && re("Tres primitives need a prop 'object'");
      const l = r.object;
      n = l.type, o = Object.assign(l, { type: n, attach: r.attach, primitive: !0 });
    } else {
      const l = q.value[n];
      l || re(`${n} is not defined on the THREE namespace. Use extend to add it to the catalog.`), o = new l(...r.args);
    }
    return o.isCamera && (r != null && r.position || o.position.set(3, 3, 3), r != null && r.lookAt || o.lookAt(0, 0, 0)), (r == null ? void 0 : r.attach) === void 0 && (o.isMaterial ? o.attach = "material" : o.isBufferGeometry && (o.attach = "geometry")), o.isObject3D && ((u = r == null ? void 0 : r.material) != null && u.isMaterial && (o.userData.tres__materialViaProp = !0), (a = r == null ? void 0 : r.geometry) != null && a.isBufferGeometry && (o.userData.tres__geometryViaProp = !0)), o.userData = {
      ...o.userData,
      tres__name: n
    }, o;
  },
  insert(e, s) {
    var r, n, o, u;
    s && s.isScene && (g = s);
    const t = s || g;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(g != null && g.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (n = g == null ? void 0 : (r = g.userData).tres__registerCamera) == null || n.call(r, e);
      }
      if (e && V.some((a) => e[a])) {
        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (u = g == null ? void 0 : (o = g.userData).tres__registerAtPointerEventHandler) == null || u.call(o, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var s, t;
    if (e) {
      if (e.isObject3D) {
        const r = e, n = (c) => {
          var f, i;
          const d = c;
          c.userData.tres__materialViaProp || ((f = d.material) == null || f.dispose(), d.material = void 0), c.userData.tres__geometryViaProp || ((i = d.geometry) == null || i.dispose(), d.geometry = void 0);
        }, o = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, u = g == null ? void 0 : g.userData.tres__deregisterBlockingObjectAtPointerEventHandler, a = (c) => {
          var d, f;
          if (!u)
            throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
          if ((f = g == null ? void 0 : (d = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || f.call(d, c), !o)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          c && V.some((i) => c[i]) && (o == null || o(c));
        }, l = (c) => {
          const d = g == null ? void 0 : g.userData.tres__deregisterCamera;
          if (!d)
            throw "could not find tres__deregisterCamera on scene's userData";
          c.isCamera && (d == null || d(c));
        };
        (s = e.removeFromParent) == null || s.call(e), r.traverse((c) => {
          n(c), l(c), a == null || a(c);
        }), n(r), l(r), a == null || a(r);
      }
      (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, s, t, r) {
    var n, o, u, a;
    if (e) {
      let l = e, c = s;
      if (e.isObject3D && c === "blocks-pointer-events") {
        r || r === "" ? (o = g == null ? void 0 : (n = g.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || o.call(n, e) : (a = g == null ? void 0 : (u = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || a.call(u, e);
        return;
      }
      let d = O(c), f = l == null ? void 0 : l[d];
      if (c === "args") {
        const m = e, h = t ?? [], p = r ?? [], y = e.userData.tres__name || e.type;
        y && h.length && !kt(h, p) && (l = Object.assign(m, new q.value[y](...r)));
        return;
      }
      if (l.type === "BufferGeometry") {
        if (c === "args")
          return;
        l.setAttribute(
          O(c),
          new $e(...r)
        );
        return;
      }
      if (c.includes("-") && f === void 0) {
        const m = c.split("-");
        f = m.reduce((h, p) => h[O(p)], l), c = m.pop(), d = c.toLowerCase(), f != null && f.set || (l = m.reduce((h, p) => h[O(p)], l));
      }
      let i = r;
      if (i === "" && (i = !0), te(f)) {
        V.includes(s) || (Array.isArray(i) ? e[d](...i) : e[d](i));
        return;
      }
      !(f != null && f.set) && !te(f) ? l[d] = i : f.constructor === i.constructor && (f != null && f.copy) ? f == null || f.copy(i) : Array.isArray(i) ? f.set(...i) : !f.isColor && f.setScalar ? f.setScalar(i) : f.set(i);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
}, { render: Ft } = he(zt);
Y(ke);
const $t = ["data-scene", "data-tres"], Nt = /* @__PURE__ */ J({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: s }) {
    var h;
    const t = e, { logWarning: r } = j(), n = L(), o = x(new Ne()), { resume: u } = ie(), a = we(), l = (h = K()) == null ? void 0 : h.appContext.app, c = (p) => J({
      setup() {
        var b;
        const y = (b = K()) == null ? void 0 : b.appContext;
        return y && (y.app = l), W("useTres", p), W("extend", Y), () => X(Ae, null, a != null && a.default ? a.default() : []);
      }
    }), d = (p) => {
      const y = c(p);
      Ft(X(y), o.value);
    }, f = (p, y = !1) => {
      o.value.children = [], y && (p.renderer.value.dispose(), p.renderer.value.renderLists.dispose(), p.renderer.value.forceContextLoss()), d(p), u();
    }, i = k(() => t.disableRender), m = x(null);
    return s({ context: m, dispose: () => f(m.value, !0) }), Ee(() => {
      const p = n;
      m.value = Rt({
        scene: o.value,
        canvas: p,
        windowSize: t.windowSize,
        disableRender: i,
        rendererOptions: t
      }), Bt({ scene: o.value, contextParts: m.value });
      const { registerCamera: y, camera: b, cameras: w, deregisterCamera: M } = m.value;
      d(m.value);
      const P = () => {
        const E = new G(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        E.position.set(3, 3, 3), E.lookAt(0, 0, 0), y(E);
        const A = D(() => {
          w.value.length >= 2 && (E.removeFromParent(), M(E), A == null || A());
        });
      };
      ne(
        () => t.camera,
        (E, A) => {
          E && y(E), A && (A.removeFromParent(), M(A));
        },
        {
          immediate: !0
        }
      ), b.value || (r(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), P());
    }), (p, y) => (be(), Ce("canvas", {
      ref_key: "canvas",
      ref: n,
      "data-scene": o.value.uuid,
      class: _e(p.$attrs.class),
      "data-tres": `tresjs ${Me(gt).version}`,
      style: Pe({
        display: "block",
        width: "100%",
        height: "100%",
        position: p.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...p.$attrs.style
      })
    }, null, 14, $t));
  }
}), It = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], Vt = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !It.includes(e) || e === "primitive"
    }
  }
}, er = Vt, tr = {
  install(e) {
    e.component("TresCanvas", Nt);
  }
};
export {
  Nt as TresCanvas,
  q as catalogue,
  tr as default,
  Y as extend,
  Yt as isProd,
  bt as normalizeColor,
  Jt as normalizeVectorFlexibleParam,
  er as templateCompilerOptions,
  Lt as trasverseObjects,
  yt as useCamera,
  Kt as useLoader,
  j as useLogger,
  Bt as usePointerEventHandler,
  jt as useRaycaster,
  ie as useRenderLoop,
  Tt as useRenderer,
  Qt as useSeek,
  Xt as useTexture,
  Zt as useTres,
  Ht as useTresContext,
  Rt as useTresContextProvider
};
